// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"

	"georgslauf/acl"
)

const countStationRoleByUser = `-- name: CountStationRoleByUser :one
select
	count(id)
from station_roles
where user_id = ?
limit 1
`

func (q *Queries) CountStationRoleByUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStationRoleByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStationRole = `-- name: CreateStationRole :exec
insert into station_roles (user_id, station_id, station_role, created_by)
values (?,?,?,?)
`

type CreateStationRoleParams struct {
	UserID      int64
	StationID   int64
	StationRole acl.ACL
	CreatedBy   sql.NullInt64
}

func (q *Queries) CreateStationRole(ctx context.Context, arg CreateStationRoleParams) error {
	_, err := q.db.ExecContext(ctx, createStationRole,
		arg.UserID,
		arg.StationID,
		arg.StationRole,
		arg.CreatedBy,
	)
	return err
}

const createTribeIcon = `-- name: CreateTribeIcon :exec
insert into tribe_icons (id, created_by, image)
values (?,?,?)
`

type CreateTribeIconParams struct {
	ID        int64
	CreatedBy sql.NullInt64
	Image     []byte
}

func (q *Queries) CreateTribeIcon(ctx context.Context, arg CreateTribeIconParams) error {
	_, err := q.db.ExecContext(ctx, createTribeIcon, arg.ID, arg.CreatedBy, arg.Image)
	return err
}

const createTribeRole = `-- name: CreateTribeRole :exec
insert into tribe_roles (user_id, tribe_id, tribe_role, created_by, accepted_at)
values (?,?,?,?,?)
`

type CreateTribeRoleParams struct {
	UserID     int64
	TribeID    int64
	TribeRole  acl.ACL
	CreatedBy  sql.NullInt64
	AcceptedAt sql.NullInt64
}

func (q *Queries) CreateTribeRole(ctx context.Context, arg CreateTribeRoleParams) error {
	_, err := q.db.ExecContext(ctx, createTribeRole,
		arg.UserID,
		arg.TribeID,
		arg.TribeRole,
		arg.CreatedBy,
		arg.AcceptedAt,
	)
	return err
}

const createUser = `-- name: CreateUser :one
insert into users (ext_id, username, firstname, lastname, email, last_login)
values (?,?,?,?,?,?)
returning id
`

type CreateUserParams struct {
	ExtID     sql.NullString
	Username  string
	Firstname string
	Lastname  string
	Email     string
	LastLogin int64
}

// TODO picture update
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ExtID,
		arg.Username,
		arg.Firstname,
		arg.Lastname,
		arg.Email,
		arg.LastLogin,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUserIcon = `-- name: CreateUserIcon :exec
insert into user_icons (id, image)
values (?,?)
on conflict(id) do update set
	image = excluded.image
`

type CreateUserIconParams struct {
	ID    int64
	Image []byte
}

func (q *Queries) CreateUserIcon(ctx context.Context, arg CreateUserIconParams) error {
	_, err := q.db.ExecContext(ctx, createUserIcon, arg.ID, arg.Image)
	return err
}

const debug = `-- name: Debug :one
select
	id
from users
limit 1
`

func (q *Queries) Debug(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, debug)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteGroup = `-- name: DeleteGroup :exec
delete from groups
where id = ?
`

func (q *Queries) DeleteGroup(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, id)
	return err
}

const deleteStation = `-- name: DeleteStation :exec
delete from stations
where id = ?
`

func (q *Queries) DeleteStation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStation, id)
	return err
}

const deleteStationCategory = `-- name: DeleteStationCategory :exec
delete from station_categories
where id = ?
`

func (q *Queries) DeleteStationCategory(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStationCategory, id)
	return err
}

const deleteStationRole = `-- name: DeleteStationRole :exec
delete from station_roles
where id = ?
`

func (q *Queries) DeleteStationRole(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStationRole, id)
	return err
}

const getCategoryOfStation = `-- name: GetCategoryOfStation :one
select
	s.category_id
	,sc.name
from stations s
left join station_categories sc
	on s.category_id = sc.id
where s.id = ?
limit 1
`

type GetCategoryOfStationRow struct {
	CategoryID sql.NullInt64
	Name       sql.NullString
}

func (q *Queries) GetCategoryOfStation(ctx context.Context, id int64) (GetCategoryOfStationRow, error) {
	row := q.db.QueryRowContext(ctx, getCategoryOfStation, id)
	var i GetCategoryOfStationRow
	err := row.Scan(&i.CategoryID, &i.Name)
	return i, err
}

const getCheckStationRoleIsTribe = `-- name: GetCheckStationRoleIsTribe :one
select
	count(sr.id)
from station_roles sr
inner join stations s
	on sr.station_id = s.id
	and sr.id = ?1
inner join tribes t
	on s.tribe_id = t.id
	and t.id = ?2
limit 1
`

type GetCheckStationRoleIsTribeParams struct {
	RoleID  int64
	TribeID int64
}

func (q *Queries) GetCheckStationRoleIsTribe(ctx context.Context, arg GetCheckStationRoleIsTribeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCheckStationRoleIsTribe, arg.RoleID, arg.TribeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getGroup = `-- name: GetGroup :one
select
	g.id
	,g.created_at
	,g.updated_at
	,g.name
	,g.abbr
	,g.size
	,g.comment
	,g.grouping
	,g.vegan
	,g.tribe_id
	,g.updated_by
	,u.firstname
	,ui.image as user_image
from groups g
left join users u
	on g.updated_by = u.id
left join user_icons ui
	on g.updated_by = ui.id
where g.id = ?
limit 1
`

type GetGroupRow struct {
	ID        int64
	CreatedAt int64
	UpdatedAt int64
	Name      string
	Abbr      sql.NullString
	Size      sql.NullInt64
	Comment   sql.NullString
	Grouping  int64
	Vegan     int64
	TribeID   int64
	UpdatedBy sql.NullInt64
	Firstname sql.NullString
	UserImage []byte
}

func (q *Queries) GetGroup(ctx context.Context, id int64) (GetGroupRow, error) {
	row := q.db.QueryRowContext(ctx, getGroup, id)
	var i GetGroupRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Abbr,
		&i.Size,
		&i.Comment,
		&i.Grouping,
		&i.Vegan,
		&i.TribeID,
		&i.UpdatedBy,
		&i.Firstname,
		&i.UserImage,
	)
	return i, err
}

const getGroupInfo = `-- name: GetGroupInfo :one
select
	g.name
	,g.abbr
	,t.name as tribe
from groups g
left join tribes t
	on g.tribe_id = t.id
where g.id = ?
limit 1
`

type GetGroupInfoRow struct {
	Name  string
	Abbr  sql.NullString
	Tribe sql.NullString
}

func (q *Queries) GetGroupInfo(ctx context.Context, id int64) (GetGroupInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupInfo, id)
	var i GetGroupInfoRow
	err := row.Scan(&i.Name, &i.Abbr, &i.Tribe)
	return i, err
}

const getGroupOverview = `-- name: GetGroupOverview :one
select
	count(id)
	,sum(size) as size
	,sum(vegan) as vegan
from groups
limit 1
`

type GetGroupOverviewRow struct {
	Count int64
	Size  sql.NullFloat64
	Vegan sql.NullFloat64
}

func (q *Queries) GetGroupOverview(ctx context.Context) (GetGroupOverviewRow, error) {
	row := q.db.QueryRowContext(ctx, getGroupOverview)
	var i GetGroupOverviewRow
	err := row.Scan(&i.Count, &i.Size, &i.Vegan)
	return i, err
}

const getGroupsAbbr = `-- name: GetGroupsAbbr :many
select
	cast(abbr as integer)
from groups
where abbr is not null
order by abbr asc
`

func (q *Queries) GetGroupsAbbr(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsAbbr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var abbr int64
		if err := rows.Scan(&abbr); err != nil {
			return nil, err
		}
		items = append(items, abbr)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsByTribe = `-- name: GetGroupsByTribe :many
select
	g.id
	,g.created_at
	,g.updated_at
	,g.name
	,g.size
	,g.grouping
	,g.comment
	,g.vegan
	,u.firstname
	,ui.image as user_image
from groups g
left join users u
	on g.updated_by = u.id
left join user_icons ui
	on g.updated_by = ui.id
where g.tribe_id = ?
order by g.created_at desc
`

type GetGroupsByTribeRow struct {
	ID        int64
	CreatedAt int64
	UpdatedAt int64
	Name      string
	Size      sql.NullInt64
	Grouping  int64
	Comment   sql.NullString
	Vegan     int64
	Firstname sql.NullString
	UserImage []byte
}

// TODO image_id
func (q *Queries) GetGroupsByTribe(ctx context.Context, tribeID int64) ([]GetGroupsByTribeRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByTribe, tribeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsByTribeRow
	for rows.Next() {
		var i GetGroupsByTribeRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Size,
			&i.Grouping,
			&i.Comment,
			&i.Vegan,
			&i.Firstname,
			&i.UserImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsDetails = `-- name: GetGroupsDetails :many
select
	g.id
	,g.name
	,g.grouping
	,g.size
	,g.abbr
	,t.name as tribe
	,ti.id as tribe_icon
from groups g
left join tribes t
	on g.tribe_id = t.id
left join tribe_icons ti
	on ti.id = t.id
order by
	g.tribe_id asc
	,g.grouping asc
	,g.created_at asc
`

type GetGroupsDetailsRow struct {
	ID        int64
	Name      string
	Grouping  int64
	Size      sql.NullInt64
	Abbr      sql.NullString
	Tribe     sql.NullString
	TribeIcon sql.NullInt64
}

func (q *Queries) GetGroupsDetails(ctx context.Context) ([]GetGroupsDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsDetailsRow
	for rows.Next() {
		var i GetGroupsDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Grouping,
			&i.Size,
			&i.Abbr,
			&i.Tribe,
			&i.TribeIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsDownload = `-- name: GetGroupsDownload :many
select
	g.id
	,g.name
	,g.abbr
	,g.size
	,g.vegan
	,g.comment
	,g.grouping
	,t.name as tribe
from groups g
left join tribes t
	on g.tribe_id = t.id
order by g.created_at asc
`

type GetGroupsDownloadRow struct {
	ID       int64
	Name     string
	Abbr     sql.NullString
	Size     sql.NullInt64
	Vegan    int64
	Comment  sql.NullString
	Grouping int64
	Tribe    sql.NullString
}

func (q *Queries) GetGroupsDownload(ctx context.Context) ([]GetGroupsDownloadRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsDownload)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsDownloadRow
	for rows.Next() {
		var i GetGroupsDownloadRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Abbr,
			&i.Size,
			&i.Vegan,
			&i.Comment,
			&i.Grouping,
			&i.Tribe,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupsHost = `-- name: GetGroupsHost :many
select
	g.id
	,g.name
	,g.grouping
	,g.tribe_id
from groups g
order by g.tribe_id asc
`

type GetGroupsHostRow struct {
	ID       int64
	Name     string
	Grouping int64
	TribeID  int64
}

func (q *Queries) GetGroupsHost(ctx context.Context) ([]GetGroupsHostRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsHost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupsHostRow
	for rows.Next() {
		var i GetGroupsHostRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Grouping,
			&i.TribeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPointsToGroups = `-- name: GetPointsToGroups :many
select
	g.id as 'group'
	,g.name
	,g.abbr
	,ptg.points
	,t.short as 'tribe'
	,g.grouping
	,ti.id as 'tribe_icon'
from groups g
left join points_to_groups ptg
	on ptg.station_id = ?
	and ptg.group_id = g.id
left join tribes t
	on g.tribe_id = t.id
left join tribe_icons ti
	on ti.id = t.id
order by
	t.short asc
	,g.grouping asc
`

type GetPointsToGroupsRow struct {
	Group     int64
	Name      string
	Abbr      sql.NullString
	Points    sql.NullInt64
	Tribe     sql.NullString
	Grouping  int64
	TribeIcon sql.NullInt64
}

func (q *Queries) GetPointsToGroups(ctx context.Context, stationID int64) ([]GetPointsToGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPointsToGroups, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPointsToGroupsRow
	for rows.Next() {
		var i GetPointsToGroupsRow
		if err := rows.Scan(
			&i.Group,
			&i.Name,
			&i.Abbr,
			&i.Points,
			&i.Tribe,
			&i.Grouping,
			&i.TribeIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPointsToStations = `-- name: GetPointsToStations :many
select
	s.id as 'station'
	,s.name
	-- TODO category
	,pts.points
	,ti.id as 'tribe_icon'
	,t.short as 'tribe'
	,sp.name as 'position'
from stations s
left join points_to_stations pts
	on pts.group_id = ?
	and pts.station_id = s.id
left join tribes t
	on s.tribe_id = t.id
left join tribe_icons ti
	on ti.id = t.id
left join station_positions sp
	on s.position_id = sp.id
order by sp.name asc
`

type GetPointsToStationsRow struct {
	Station   int64
	Name      string
	Points    sql.NullInt64
	TribeIcon sql.NullInt64
	Tribe     sql.NullString
	Position  sql.NullString
}

func (q *Queries) GetPointsToStations(ctx context.Context, groupID int64) ([]GetPointsToStationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPointsToStations, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPointsToStationsRow
	for rows.Next() {
		var i GetPointsToStationsRow
		if err := rows.Scan(
			&i.Station,
			&i.Name,
			&i.Points,
			&i.TribeIcon,
			&i.Tribe,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResultsGroups = `-- name: GetResultsGroups :many
select
	g.id
	,g.name
	,sum(ptg.points)
	,g.grouping
	,g.abbr
	,t.name as tribe
	,ti.id as tribe_icon
from groups g
left join points_to_groups ptg
	on ptg.group_id = g.id
left join tribes t
	on g.tribe_id = t.id
left join tribe_icons ti
	on ti.id = t.id
group by g.id
order by 3 desc
`

type GetResultsGroupsRow struct {
	ID        int64
	Name      string
	Sum       sql.NullFloat64
	Grouping  int64
	Abbr      sql.NullString
	Tribe     sql.NullString
	TribeIcon sql.NullInt64
}

func (q *Queries) GetResultsGroups(ctx context.Context) ([]GetResultsGroupsRow, error) {
	rows, err := q.db.QueryContext(ctx, getResultsGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResultsGroupsRow
	for rows.Next() {
		var i GetResultsGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sum,
			&i.Grouping,
			&i.Abbr,
			&i.Tribe,
			&i.TribeIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResultsStations = `-- name: GetResultsStations :many
select
	s.id
	,s.name
	,sum(pts.points)
	,sp.name as position
	,t.name as tribe
	,ti.id as tribe_icon
from stations s
left join points_to_stations pts
	on pts.station_id = s.id
left join station_positions sp
	on s.position_id = sp.id
left join tribes t
	on s.tribe_id = t.id
left join tribe_icons ti
	on ti.id = t.id
group by s.id
order by 3 desc
`

type GetResultsStationsRow struct {
	ID        int64
	Name      string
	Sum       sql.NullFloat64
	Position  sql.NullString
	Tribe     sql.NullString
	TribeIcon sql.NullInt64
}

func (q *Queries) GetResultsStations(ctx context.Context) ([]GetResultsStationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getResultsStations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResultsStationsRow
	for rows.Next() {
		var i GetResultsStationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Sum,
			&i.Position,
			&i.Tribe,
			&i.TribeIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedule = `-- name: GetSchedule :many
select id, start, "end", name
from schedule
order by "start" asc
`

func (q *Queries) GetSchedule(ctx context.Context) ([]Schedule, error) {
	rows, err := q.db.QueryContext(ctx, getSchedule)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Schedule
	for rows.Next() {
		var i Schedule
		if err := rows.Scan(
			&i.ID,
			&i.Start,
			&i.End,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettings = `-- name: GetSettings :one
select
	id, updated_at, updated_by, data
from settings
limit 1
`

func (q *Queries) GetSettings(ctx context.Context) (Setting, error) {
	row := q.db.QueryRowContext(ctx, getSettings)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Data,
	)
	return i, err
}

const getStation = `-- name: GetStation :one
select
	s.id
	,s.created_at
	,s.updated_at
	,s.name
	,s.size
	,s.category_id
	,s.description
	,s.requirements
	,s.vegan
	,s.tribe_id
	,s.updated_by
	,s.position_id
	,sc.name as category_name
	,sp.name as position_name
	,u.firstname
	,ui.image as user_image
from stations s
left join station_categories sc
	on category_id = sc.id
left join station_positions sp
	on position_id = sp.id
left join users u
	on s.updated_by = u.id
left join user_icons ui
	on s.updated_by = ui.id
where s.id = ?
limit 1
`

type GetStationRow struct {
	ID           int64
	CreatedAt    int64
	UpdatedAt    int64
	Name         string
	Size         int64
	CategoryID   sql.NullInt64
	Description  sql.NullString
	Requirements sql.NullString
	Vegan        int64
	TribeID      int64
	UpdatedBy    sql.NullInt64
	PositionID   sql.NullInt64
	CategoryName sql.NullString
	PositionName sql.NullString
	Firstname    sql.NullString
	UserImage    []byte
}

func (q *Queries) GetStation(ctx context.Context, id int64) (GetStationRow, error) {
	row := q.db.QueryRowContext(ctx, getStation, id)
	var i GetStationRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Size,
		&i.CategoryID,
		&i.Description,
		&i.Requirements,
		&i.Vegan,
		&i.TribeID,
		&i.UpdatedBy,
		&i.PositionID,
		&i.CategoryName,
		&i.PositionName,
		&i.Firstname,
		&i.UserImage,
	)
	return i, err
}

const getStationByIdAndTribe = `-- name: GetStationByIdAndTribe :one
select
	count(id)
from stations
where id = ?
and tribe_id = ?
limit 1
`

type GetStationByIdAndTribeParams struct {
	ID      int64
	TribeID int64
}

func (q *Queries) GetStationByIdAndTribe(ctx context.Context, arg GetStationByIdAndTribeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStationByIdAndTribe, arg.ID, arg.TribeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStationCategories = `-- name: GetStationCategories :many
select
	sc.id
	,sc.name
	,sc.max
	,count(s.id) as count
from station_categories sc
left join stations s
	on s.category_id = sc.id
group by sc.id
`

type GetStationCategoriesRow struct {
	ID    int64
	Name  string
	Max   int64
	Count int64
}

func (q *Queries) GetStationCategories(ctx context.Context) ([]GetStationCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationCategoriesRow
	for rows.Next() {
		var i GetStationCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Max,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationCategory = `-- name: GetStationCategory :one
select
	id
	,name
	,max
from station_categories
where id = ?
limit 1
`

func (q *Queries) GetStationCategory(ctx context.Context, id int64) (StationCategory, error) {
	row := q.db.QueryRowContext(ctx, getStationCategory, id)
	var i StationCategory
	err := row.Scan(&i.ID, &i.Name, &i.Max)
	return i, err
}

const getStationCategoryCount = `-- name: GetStationCategoryCount :one
select
	count(id)
from stations
where category_id = ?
limit 1
`

func (q *Queries) GetStationCategoryCount(ctx context.Context, categoryID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStationCategoryCount, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStationInfo = `-- name: GetStationInfo :one
select
	s.name
	,sp.name as position
	,t.name as tribe
from stations s
left join station_positions sp
	on s.position_id = sp.id
left join tribes t
	on s.tribe_id = t.id
where s.id = ?
limit 1
`

type GetStationInfoRow struct {
	Name     string
	Position sql.NullString
	Tribe    sql.NullString
}

func (q *Queries) GetStationInfo(ctx context.Context, id int64) (GetStationInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getStationInfo, id)
	var i GetStationInfoRow
	err := row.Scan(&i.Name, &i.Position, &i.Tribe)
	return i, err
}

const getStationName = `-- name: GetStationName :one
select
	s.id
	,s.name
from stations s
where s.id = ?
limit 1
`

type GetStationNameRow struct {
	ID   int64
	Name string
}

func (q *Queries) GetStationName(ctx context.Context, id int64) (GetStationNameRow, error) {
	row := q.db.QueryRowContext(ctx, getStationName, id)
	var i GetStationNameRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getStationOverview = `-- name: GetStationOverview :one
select
	count(id)
	,sum(size) as size
	,sum(vegan) as vegan
from stations
limit 1
`

type GetStationOverviewRow struct {
	Count int64
	Size  sql.NullFloat64
	Vegan sql.NullFloat64
}

func (q *Queries) GetStationOverview(ctx context.Context) (GetStationOverviewRow, error) {
	row := q.db.QueryRowContext(ctx, getStationOverview)
	var i GetStationOverviewRow
	err := row.Scan(&i.Count, &i.Size, &i.Vegan)
	return i, err
}

const getStationPointsAverageOther = `-- name: GetStationPointsAverageOther :many
select
	s.id
	,s.name
	,t.name as 'tribe'
	,avg(ptg.points) as 'avg'
from points_to_groups ptg
inner join stations s
	on ptg.station_id = s.id
inner join tribes t
	on s.tribe_id = t.id
inner join groups g
	on ptg.group_id = g.id
	and g.tribe_id != s.tribe_id
group by
	s.id
`

type GetStationPointsAverageOtherRow struct {
	ID    int64
	Name  string
	Tribe string
	Avg   sql.NullFloat64
}

// filters non set points
func (q *Queries) GetStationPointsAverageOther(ctx context.Context) ([]GetStationPointsAverageOtherRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationPointsAverageOther)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationPointsAverageOtherRow
	for rows.Next() {
		var i GetStationPointsAverageOtherRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Tribe,
			&i.Avg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationPointsAverageSame = `-- name: GetStationPointsAverageSame :many
select
	s.id
	,s.name
	,t.name as 'tribe'
	,avg(ptg.points) as 'avg'
from points_to_groups ptg
inner join stations s
	on ptg.station_id = s.id
inner join tribes t
	on s.tribe_id = t.id
inner join groups g
	on ptg.group_id = g.id
	and g.tribe_id = s.tribe_id
group by
	s.id
`

type GetStationPointsAverageSameRow struct {
	ID    int64
	Name  string
	Tribe string
	Avg   sql.NullFloat64
}

// filters non set points
func (q *Queries) GetStationPointsAverageSame(ctx context.Context) ([]GetStationPointsAverageSameRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationPointsAverageSame)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationPointsAverageSameRow
	for rows.Next() {
		var i GetStationPointsAverageSameRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Tribe,
			&i.Avg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationPosition = `-- name: GetStationPosition :one
select
	name
from station_positions
where id = ?
limit 1
`

func (q *Queries) GetStationPosition(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getStationPosition, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getStationPositionsOpen = `-- name: GetStationPositionsOpen :many
select
	sp.id
	,sp.name
from station_positions sp
left join stations s
	on sp.id = s.position_id
where s.position_id is null
`

func (q *Queries) GetStationPositionsOpen(ctx context.Context) ([]StationPosition, error) {
	rows, err := q.db.QueryContext(ctx, getStationPositionsOpen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StationPosition
	for rows.Next() {
		var i StationPosition
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationPositionsStation = `-- name: GetStationPositionsStation :many
select
	sp.name as position_name
	,s.name as station_name
from station_positions sp
left join stations s
	on sp.id = s.position_id
`

type GetStationPositionsStationRow struct {
	PositionName string
	StationName  sql.NullString
}

func (q *Queries) GetStationPositionsStation(ctx context.Context) ([]GetStationPositionsStationRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationPositionsStation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationPositionsStationRow
	for rows.Next() {
		var i GetStationPositionsStationRow
		if err := rows.Scan(&i.PositionName, &i.StationName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationRoleById = `-- name: GetStationRoleById :one
select
	sr.id
	,sr.station_role
	,u.email
	,ui.image
	,u.firstname
	,u.lastname
	,s.name as station_name
from station_roles sr
inner join users u
	on sr.user_id = u.id
inner join stations s
	on sr.station_id = s.id
left join user_icons ui
	on ui.id = sr.user_id
where
	sr.id = ?
limit 1
`

type GetStationRoleByIdRow struct {
	ID          int64
	StationRole acl.ACL
	Email       string
	Image       []byte
	Firstname   string
	Lastname    string
	StationName string
}

func (q *Queries) GetStationRoleById(ctx context.Context, id int64) (GetStationRoleByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getStationRoleById, id)
	var i GetStationRoleByIdRow
	err := row.Scan(
		&i.ID,
		&i.StationRole,
		&i.Email,
		&i.Image,
		&i.Firstname,
		&i.Lastname,
		&i.StationName,
	)
	return i, err
}

const getStationRoleByUser = `-- name: GetStationRoleByUser :one
select
	sr.station_id
	,sr.station_role
from station_roles sr
where
	sr.user_id = ?
limit 1
`

type GetStationRoleByUserRow struct {
	StationID   int64
	StationRole acl.ACL
}

func (q *Queries) GetStationRoleByUser(ctx context.Context, userID int64) (GetStationRoleByUserRow, error) {
	row := q.db.QueryRowContext(ctx, getStationRoleByUser, userID)
	var i GetStationRoleByUserRow
	err := row.Scan(&i.StationID, &i.StationRole)
	return i, err
}

const getStationRoleStation = `-- name: GetStationRoleStation :one
select
	station_id
from station_roles
where id = ?
limit 1
`

func (q *Queries) GetStationRoleStation(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStationRoleStation, id)
	var station_id int64
	err := row.Scan(&station_id)
	return station_id, err
}

const getStationRoleStationWithUser = `-- name: GetStationRoleStationWithUser :one
select
	station_id
	,user_id
from station_roles
where id = ?
limit 1
`

type GetStationRoleStationWithUserRow struct {
	StationID int64
	UserID    int64
}

func (q *Queries) GetStationRoleStationWithUser(ctx context.Context, id int64) (GetStationRoleStationWithUserRow, error) {
	row := q.db.QueryRowContext(ctx, getStationRoleStationWithUser, id)
	var i GetStationRoleStationWithUserRow
	err := row.Scan(&i.StationID, &i.UserID)
	return i, err
}

const getStationRoles = `-- name: GetStationRoles :many
select
	sr.id
	,sr.station_id
	,sr.station_role
	,u.email
from station_roles sr
left join users u
	on sr.user_id = u.id
`

type GetStationRolesRow struct {
	ID          int64
	StationID   int64
	StationRole acl.ACL
	Email       sql.NullString
}

func (q *Queries) GetStationRoles(ctx context.Context) ([]GetStationRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationRolesRow
	for rows.Next() {
		var i GetStationRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.StationID,
			&i.StationRole,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationRolesDash = `-- name: GetStationRolesDash :many
select
	sr.id
	,sr.station_id
	,sr.station_role
	,u.email
from station_roles sr
inner join stations s
	on sr.station_id = s.id
	and s.tribe_id = ?
inner join users u
	on sr.user_id = u.id
`

type GetStationRolesDashRow struct {
	ID          int64
	StationID   int64
	StationRole acl.ACL
	Email       string
}

// NTH join station required?
func (q *Queries) GetStationRolesDash(ctx context.Context, tribeID int64) ([]GetStationRolesDashRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationRolesDash, tribeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationRolesDashRow
	for rows.Next() {
		var i GetStationRolesDashRow
		if err := rows.Scan(
			&i.ID,
			&i.StationID,
			&i.StationRole,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationRolesInStation = `-- name: GetStationRolesInStation :many
select
	sr.id
	,sr.station_role
	,u.firstname
	,u.lastname
	,u.email
from station_roles sr
inner join users u
	on sr.user_id = u.id
where sr.station_id = ?
`

type GetStationRolesInStationRow struct {
	ID          int64
	StationRole acl.ACL
	Firstname   string
	Lastname    string
	Email       string
}

func (q *Queries) GetStationRolesInStation(ctx context.Context, stationID int64) ([]GetStationRolesInStationRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationRolesInStation, stationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationRolesInStationRow
	for rows.Next() {
		var i GetStationRolesInStationRow
		if err := rows.Scan(
			&i.ID,
			&i.StationRole,
			&i.Firstname,
			&i.Lastname,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationsByTribe = `-- name: GetStationsByTribe :many
select
	s.id
	,s.created_at
	,s.updated_at
	,s.name
	,s.size
	,s.category_id
	,s.description
	,s.requirements
	,s.vegan
	,sp.id as position_id
	,sp.name as position_name
	,sc.name as category_name
	,u.firstname
	,ui.image as user_image
from stations s
left join station_categories sc
	on category_id = sc.id
left join station_positions sp
	on position_id = sp.id
left join users u
	on s.updated_by = u.id
left join user_icons ui
	on s.updated_by = ui.id
where s.tribe_id = ?
order by s.created_at desc
`

type GetStationsByTribeRow struct {
	ID           int64
	CreatedAt    int64
	UpdatedAt    int64
	Name         string
	Size         int64
	CategoryID   sql.NullInt64
	Description  sql.NullString
	Requirements sql.NullString
	Vegan        int64
	PositionID   sql.NullInt64
	PositionName sql.NullString
	CategoryName sql.NullString
	Firstname    sql.NullString
	UserImage    []byte
}

func (q *Queries) GetStationsByTribe(ctx context.Context, tribeID int64) ([]GetStationsByTribeRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationsByTribe, tribeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationsByTribeRow
	for rows.Next() {
		var i GetStationsByTribeRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Size,
			&i.CategoryID,
			&i.Description,
			&i.Requirements,
			&i.Vegan,
			&i.PositionID,
			&i.PositionName,
			&i.CategoryName,
			&i.Firstname,
			&i.UserImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationsDetails = `-- name: GetStationsDetails :many
select
	s.id
	,s.name
	,sp.name as position_name
	,sc.name as category_name
	,t.name as tribe
	,s.size
	,ti.id as tribe_icon
from stations s
left join tribes t
	on s.tribe_id = t.id
left join tribe_icons ti
	on ti.id = t.id
left join station_categories sc
	on s.category_id = sc.id
left join station_positions sp
	on s.position_id = sp.id
order by
	s.tribe_id asc
	,s.created_at asc
`

type GetStationsDetailsRow struct {
	ID           int64
	Name         string
	PositionName sql.NullString
	CategoryName sql.NullString
	Tribe        sql.NullString
	Size         int64
	TribeIcon    sql.NullInt64
}

func (q *Queries) GetStationsDetails(ctx context.Context) ([]GetStationsDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationsDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationsDetailsRow
	for rows.Next() {
		var i GetStationsDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PositionName,
			&i.CategoryName,
			&i.Tribe,
			&i.Size,
			&i.TribeIcon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationsDownload = `-- name: GetStationsDownload :many
select
	s.id
	,s.name
	,s.size
	,s.vegan
	,s.description
	,s.requirements
	,sp.name as position
	,t.name as tribe
	,sc.name as category
from stations s
left join tribes t
	on s.tribe_id = t.id
left join station_positions sp
	on s.position_id = sp.id
left join station_categories sc
	on s.category_id = sc.id
order by s.created_at asc
`

type GetStationsDownloadRow struct {
	ID           int64
	Name         string
	Size         int64
	Vegan        int64
	Description  sql.NullString
	Requirements sql.NullString
	Position     sql.NullString
	Tribe        sql.NullString
	Category     sql.NullString
}

func (q *Queries) GetStationsDownload(ctx context.Context) ([]GetStationsDownloadRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationsDownload)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationsDownloadRow
	for rows.Next() {
		var i GetStationsDownloadRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Size,
			&i.Vegan,
			&i.Description,
			&i.Requirements,
			&i.Position,
			&i.Tribe,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStationsHost = `-- name: GetStationsHost :many
select
	id
	,name
	,tribe_id
from stations
order by tribe_id asc
`

type GetStationsHostRow struct {
	ID      int64
	Name    string
	TribeID int64
}

func (q *Queries) GetStationsHost(ctx context.Context) ([]GetStationsHostRow, error) {
	rows, err := q.db.QueryContext(ctx, getStationsHost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStationsHostRow
	for rows.Next() {
		var i GetStationsHostRow
		if err := rows.Scan(&i.ID, &i.Name, &i.TribeID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTribeByEmail = `-- name: GetTribeByEmail :one
select
	id
	,name
	,dpsg
from tribes
where email_domain = ?
limit 1
`

type GetTribeByEmailRow struct {
	ID   int64
	Name string
	Dpsg sql.NullString
}

func (q *Queries) GetTribeByEmail(ctx context.Context, emailDomain sql.NullString) (GetTribeByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getTribeByEmail, emailDomain)
	var i GetTribeByEmailRow
	err := row.Scan(&i.ID, &i.Name, &i.Dpsg)
	return i, err
}

const getTribeIcon = `-- name: GetTribeIcon :one
select
	image
from tribe_icons
where id = ?
limit 1
`

func (q *Queries) GetTribeIcon(ctx context.Context, id int64) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getTribeIcon, id)
	var image []byte
	err := row.Scan(&image)
	return image, err
}

const getTribeNameIcon = `-- name: GetTribeNameIcon :one
select
	t.name
	,ti.id as tribe_icon
from tribes t
left join tribe_icons ti
	on ti.id = t.id
where
	t.id = ?
limit 1
`

type GetTribeNameIconRow struct {
	Name      string
	TribeIcon sql.NullInt64
}

func (q *Queries) GetTribeNameIcon(ctx context.Context, id int64) (GetTribeNameIconRow, error) {
	row := q.db.QueryRowContext(ctx, getTribeNameIcon, id)
	var i GetTribeNameIconRow
	err := row.Scan(&i.Name, &i.TribeIcon)
	return i, err
}

const getTribeRoleById = `-- name: GetTribeRoleById :one
select
	tr.id
	,tr.tribe_role
	,tr.accepted_at
	,u.email
	,ui.image
	,u.firstname
	,u.lastname
	,t.name as tribe_name
	,t.short
	,t.email_domain
	,ti.id as tribe_icon
from tribe_roles tr
inner join users u
	on tr.user_id = u.id
inner join tribes t
	on tr.tribe_id = t.id
left join user_icons ui
	on ui.id = tr.user_id
left join tribe_icons ti
	on ti.id = tr.tribe_id
where
	tr.id = ?
limit 1
`

type GetTribeRoleByIdRow struct {
	ID          int64
	TribeRole   acl.ACL
	AcceptedAt  sql.NullInt64
	Email       string
	Image       []byte
	Firstname   string
	Lastname    string
	TribeName   string
	Short       sql.NullString
	EmailDomain sql.NullString
	TribeIcon   sql.NullInt64
}

func (q *Queries) GetTribeRoleById(ctx context.Context, id int64) (GetTribeRoleByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getTribeRoleById, id)
	var i GetTribeRoleByIdRow
	err := row.Scan(
		&i.ID,
		&i.TribeRole,
		&i.AcceptedAt,
		&i.Email,
		&i.Image,
		&i.Firstname,
		&i.Lastname,
		&i.TribeName,
		&i.Short,
		&i.EmailDomain,
		&i.TribeIcon,
	)
	return i, err
}

const getTribeRoleByTribe = `-- name: GetTribeRoleByTribe :one
select
	tr.tribe_role
	,ti.id as icon_id
	,tr.accepted_at
from tribe_roles tr
left join tribe_icons ti
	on ti.id = tr.id
where
	tr.user_id = ?
	and tr.tribe_id = ?
limit 1
`

type GetTribeRoleByTribeParams struct {
	UserID  int64
	TribeID int64
}

type GetTribeRoleByTribeRow struct {
	TribeRole  acl.ACL
	IconID     sql.NullInt64
	AcceptedAt sql.NullInt64
}

func (q *Queries) GetTribeRoleByTribe(ctx context.Context, arg GetTribeRoleByTribeParams) (GetTribeRoleByTribeRow, error) {
	row := q.db.QueryRowContext(ctx, getTribeRoleByTribe, arg.UserID, arg.TribeID)
	var i GetTribeRoleByTribeRow
	err := row.Scan(&i.TribeRole, &i.IconID, &i.AcceptedAt)
	return i, err
}

const getTribeRoleWithIcon = `-- name: GetTribeRoleWithIcon :one
select
	tr.tribe_role
	,tr.tribe_id
	,ti.id as icon_id
	,tr.accepted_at
from tribe_roles tr
left join tribe_icons ti
	on ti.id = tr.id
left join tribes t
	on tr.tribe_id = t.id
where
	tr.user_id = ?
limit 1
`

type GetTribeRoleWithIconRow struct {
	TribeRole  acl.ACL
	TribeID    int64
	IconID     sql.NullInt64
	AcceptedAt sql.NullInt64
}

func (q *Queries) GetTribeRoleWithIcon(ctx context.Context, userID int64) (GetTribeRoleWithIconRow, error) {
	row := q.db.QueryRowContext(ctx, getTribeRoleWithIcon, userID)
	var i GetTribeRoleWithIconRow
	err := row.Scan(
		&i.TribeRole,
		&i.TribeID,
		&i.IconID,
		&i.AcceptedAt,
	)
	return i, err
}

const getTribeRolesAssigned = `-- name: GetTribeRolesAssigned :many
select
	tr.id
	,tr.tribe_id
	,u.email
	,tr.tribe_role
from tribe_roles tr
inner join users u
	on u.id = tr.user_id
where
	accepted_at is not null
	or tr.tribe_role = -1
order by tr.tribe_id asc
`

type GetTribeRolesAssignedRow struct {
	ID        int64
	TribeID   int64
	Email     string
	TribeRole acl.ACL
}

func (q *Queries) GetTribeRolesAssigned(ctx context.Context) ([]GetTribeRolesAssignedRow, error) {
	rows, err := q.db.QueryContext(ctx, getTribeRolesAssigned)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTribeRolesAssignedRow
	for rows.Next() {
		var i GetTribeRolesAssignedRow
		if err := rows.Scan(
			&i.ID,
			&i.TribeID,
			&i.Email,
			&i.TribeRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTribeRolesOpen = `-- name: GetTribeRolesOpen :many
select
	tr.id
	,tr.created_at
	,t.name as tribe_name
	,u.email as user_email
	,u.firstname
	,u.lastname
	,ui.image as user_icon
	,ti.id as tribe_icon_id
from tribe_roles tr
inner join users u
	on u.id = tr.user_id
inner join tribes t
	on t.id = tr.tribe_id
left join user_icons ui
	on ui.id = tr.user_id
left join tribe_icons ti
	on ti.id = tr.tribe_id
where
	tribe_role = 0
	and accepted_at is null
order by tr.created_at desc
`

type GetTribeRolesOpenRow struct {
	ID          int64
	CreatedAt   int64
	TribeName   string
	UserEmail   string
	Firstname   string
	Lastname    string
	UserIcon    []byte
	TribeIconID sql.NullInt64
}

// NTH multiple smaller queries
func (q *Queries) GetTribeRolesOpen(ctx context.Context) ([]GetTribeRolesOpenRow, error) {
	rows, err := q.db.QueryContext(ctx, getTribeRolesOpen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTribeRolesOpenRow
	for rows.Next() {
		var i GetTribeRolesOpenRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.TribeName,
			&i.UserEmail,
			&i.Firstname,
			&i.Lastname,
			&i.UserIcon,
			&i.TribeIconID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTribes = `-- name: GetTribes :many
select
	t.id, t.created_at, t.updated_at, t.name, t.short, t.dpsg, t.image_id, t.email_domain, t.stavo_email
	,ti.id as icon
from tribes t
left join tribe_icons ti
	on ti.id = t.id
`

type GetTribesRow struct {
	ID          int64
	CreatedAt   int64
	UpdatedAt   int64
	Name        string
	Short       sql.NullString
	Dpsg        sql.NullString
	ImageID     sql.NullString
	EmailDomain sql.NullString
	StavoEmail  sql.NullString
	Icon        sql.NullInt64
}

func (q *Queries) GetTribes(ctx context.Context) ([]GetTribesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTribes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTribesRow
	for rows.Next() {
		var i GetTribesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Short,
			&i.Dpsg,
			&i.ImageID,
			&i.EmailDomain,
			&i.StavoEmail,
			&i.Icon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTribesName = `-- name: GetTribesName :many
select
	t.id
	,t.short
	,t.name
from tribes t
`

type GetTribesNameRow struct {
	ID    int64
	Short sql.NullString
	Name  string
}

func (q *Queries) GetTribesName(ctx context.Context) ([]GetTribesNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getTribesName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTribesNameRow
	for rows.Next() {
		var i GetTribesNameRow
		if err := rows.Scan(&i.ID, &i.Short, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserIcon = `-- name: GetUserIcon :one
select
	image
from user_icons
where id = ?
limit 1
`

func (q *Queries) GetUserIcon(ctx context.Context, id int64) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getUserIcon, id)
	var image []byte
	err := row.Scan(&image)
	return image, err
}

const getUserIdByExt = `-- name: GetUserIdByExt :one
select
	id
	,role
	,last_login
from users
where
	ext_id = ?
limit 1
`

type GetUserIdByExtRow struct {
	ID        int64
	Role      acl.ACL
	LastLogin int64
}

func (q *Queries) GetUserIdByExt(ctx context.Context, extID sql.NullString) (GetUserIdByExtRow, error) {
	row := q.db.QueryRowContext(ctx, getUserIdByExt, extID)
	var i GetUserIdByExtRow
	err := row.Scan(&i.ID, &i.Role, &i.LastLogin)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
select
	role
from users
where id = ?
limit 1
`

func (q *Queries) GetUserRole(ctx context.Context, id int64) (acl.ACL, error) {
	row := q.db.QueryRowContext(ctx, getUserRole, id)
	var role acl.ACL
	err := row.Scan(&role)
	return role, err
}

const getUserWithTribeRole = `-- name: GetUserWithTribeRole :one
select
	count(u.id)
from users u
inner join tribe_roles tr
	on tr.user_id = u.id
	and tr.tribe_id = ?
	and u.id = ?
limit 1
`

type GetUserWithTribeRoleParams struct {
	TribeID int64
	ID      int64
}

func (q *Queries) GetUserWithTribeRole(ctx context.Context, arg GetUserWithTribeRoleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserWithTribeRole, arg.TribeID, arg.ID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUsersByTribeRole = `-- name: GetUsersByTribeRole :many
select
	u.id
	,u.email
from users u
inner join tribe_roles tr
	on tr.user_id = u.id
	and tr.tribe_id = ?
`

type GetUsersByTribeRoleRow struct {
	ID    int64
	Email string
}

func (q *Queries) GetUsersByTribeRole(ctx context.Context, tribeID int64) ([]GetUsersByTribeRoleRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByTribeRole, tribeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByTribeRoleRow
	for rows.Next() {
		var i GetUsersByTribeRoleRow
		if err := rows.Scan(&i.ID, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersOrdered = `-- name: GetUsersOrdered :many
select
	u.id
	,u.email
	,t.short as tribe_name
from users u
left join tribe_roles tr
	on tr.user_id = u.id
left join tribes t
	on tr.tribe_id = t.id
order by
	tr.tribe_id asc
`

type GetUsersOrderedRow struct {
	ID        int64
	Email     string
	TribeName sql.NullString
}

func (q *Queries) GetUsersOrdered(ctx context.Context) ([]GetUsersOrderedRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersOrdered)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersOrderedRow
	for rows.Next() {
		var i GetUsersOrderedRow
		if err := rows.Scan(&i.ID, &i.Email, &i.TribeName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersRoleLargerNone = `-- name: GetUsersRoleLargerNone :many
select
	u.id
	,u.email
	,u.last_login
	,u.created_at
	,u.role
	,u.firstname
	,u.lastname
	,ui.image
from users u
left join user_icons ui
	on ui.id = u.id
where u.role > 0
`

type GetUsersRoleLargerNoneRow struct {
	ID        int64
	Email     string
	LastLogin int64
	CreatedAt int64
	Role      acl.ACL
	Firstname string
	Lastname  string
	Image     []byte
}

func (q *Queries) GetUsersRoleLargerNone(ctx context.Context) ([]GetUsersRoleLargerNoneRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersRoleLargerNone)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRoleLargerNoneRow
	for rows.Next() {
		var i GetUsersRoleLargerNoneRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.LastLogin,
			&i.CreatedAt,
			&i.Role,
			&i.Firstname,
			&i.Lastname,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersRoleNone = `-- name: GetUsersRoleNone :many
select
	id
	,email
	,created_at
	,firstname
	,lastname
from users
where role = 0
order by created_at desc
`

type GetUsersRoleNoneRow struct {
	ID        int64
	Email     string
	CreatedAt int64
	Firstname string
	Lastname  string
}

func (q *Queries) GetUsersRoleNone(ctx context.Context) ([]GetUsersRoleNoneRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersRoleNone)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRoleNoneRow
	for rows.Next() {
		var i GetUsersRoleNoneRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.CreatedAt,
			&i.Firstname,
			&i.Lastname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertGroup = `-- name: InsertGroup :one
insert into groups (name, size, tribe_id, grouping, comment, created_by, updated_by, created_at, updated_at, vegan)
values (?,?,?,?,?,?,?,?,?,?)
returning id
`

type InsertGroupParams struct {
	Name      string
	Size      sql.NullInt64
	TribeID   int64
	Grouping  int64
	Comment   sql.NullString
	CreatedBy sql.NullInt64
	UpdatedBy sql.NullInt64
	CreatedAt int64
	UpdatedAt int64
	Vegan     int64
}

func (q *Queries) InsertGroup(ctx context.Context, arg InsertGroupParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertGroup,
		arg.Name,
		arg.Size,
		arg.TribeID,
		arg.Grouping,
		arg.Comment,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Vegan,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertSettings = `-- name: InsertSettings :exec
insert into settings (data) values (?)
`

func (q *Queries) InsertSettings(ctx context.Context, data []byte) error {
	_, err := q.db.ExecContext(ctx, insertSettings, data)
	return err
}

const insertStation = `-- name: InsertStation :one
insert into stations (name, size, tribe_id, category_id, description, requirements, created_by, created_at, updated_at, updated_by, vegan, position_id)
values (?,?,?,?,?,?,?,?,?,?,?,?)
returning id
`

type InsertStationParams struct {
	Name         string
	Size         int64
	TribeID      int64
	CategoryID   sql.NullInt64
	Description  sql.NullString
	Requirements sql.NullString
	CreatedBy    sql.NullInt64
	CreatedAt    int64
	UpdatedAt    int64
	UpdatedBy    sql.NullInt64
	Vegan        int64
	PositionID   sql.NullInt64
}

func (q *Queries) InsertStation(ctx context.Context, arg InsertStationParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertStation,
		arg.Name,
		arg.Size,
		arg.TribeID,
		arg.CategoryID,
		arg.Description,
		arg.Requirements,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Vegan,
		arg.PositionID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertStationCateogy = `-- name: InsertStationCateogy :one
insert into station_categories (name, max)
values (?,?)
returning id
`

type InsertStationCateogyParams struct {
	Name string
	Max  int64
}

func (q *Queries) InsertStationCateogy(ctx context.Context, arg InsertStationCateogyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertStationCateogy, arg.Name, arg.Max)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateGroup = `-- name: UpdateGroup :exec
update groups
set
	name = ?
	,size = ?
	,grouping = ?
	,comment = ?
	,updated_at = ?
	,updated_by = ?
	,vegan = ?
where
	id = ?
	and tribe_id = ?
`

type UpdateGroupParams struct {
	Name      string
	Size      sql.NullInt64
	Grouping  int64
	Comment   sql.NullString
	UpdatedAt int64
	UpdatedBy sql.NullInt64
	Vegan     int64
	ID        int64
	TribeID   int64
}

func (q *Queries) UpdateGroup(ctx context.Context, arg UpdateGroupParams) error {
	_, err := q.db.ExecContext(ctx, updateGroup,
		arg.Name,
		arg.Size,
		arg.Grouping,
		arg.Comment,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Vegan,
		arg.ID,
		arg.TribeID,
	)
	return err
}

const updateGroupHost = `-- name: UpdateGroupHost :exec
update groups
set
	name = ?
	,size = ?
	,grouping = ?
	,comment = ?
	,updated_at = ?
	,updated_by = ?
	,vegan = ?
	,abbr = ?
	,tribe_id = ?
where
	id = ?
`

type UpdateGroupHostParams struct {
	Name      string
	Size      sql.NullInt64
	Grouping  int64
	Comment   sql.NullString
	UpdatedAt int64
	UpdatedBy sql.NullInt64
	Vegan     int64
	Abbr      sql.NullString
	TribeID   int64
	ID        int64
}

func (q *Queries) UpdateGroupHost(ctx context.Context, arg UpdateGroupHostParams) error {
	_, err := q.db.ExecContext(ctx, updateGroupHost,
		arg.Name,
		arg.Size,
		arg.Grouping,
		arg.Comment,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Vegan,
		arg.Abbr,
		arg.TribeID,
		arg.ID,
	)
	return err
}

const updateSettings = `-- name: UpdateSettings :exec
update settings
set
	updated_at = unixepoch()
	,updated_by = ?
	,data = ?
`

type UpdateSettingsParams struct {
	UpdatedBy sql.NullInt64
	Data      []byte
}

// NTH where id = ?
func (q *Queries) UpdateSettings(ctx context.Context, arg UpdateSettingsParams) error {
	_, err := q.db.ExecContext(ctx, updateSettings, arg.UpdatedBy, arg.Data)
	return err
}

const updateStation = `-- name: UpdateStation :exec
update stations
set
	updated_at = ?
	,updated_by = ?
	,name = ?
	,size = ?
	,category_id = ?
	,description = ?
	,requirements = ?
	,vegan = ?
	,position_id = ?
where
	id = ?
	and tribe_id = ?
`

type UpdateStationParams struct {
	UpdatedAt    int64
	UpdatedBy    sql.NullInt64
	Name         string
	Size         int64
	CategoryID   sql.NullInt64
	Description  sql.NullString
	Requirements sql.NullString
	Vegan        int64
	PositionID   sql.NullInt64
	ID           int64
	TribeID      int64
}

func (q *Queries) UpdateStation(ctx context.Context, arg UpdateStationParams) error {
	_, err := q.db.ExecContext(ctx, updateStation,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Name,
		arg.Size,
		arg.CategoryID,
		arg.Description,
		arg.Requirements,
		arg.Vegan,
		arg.PositionID,
		arg.ID,
		arg.TribeID,
	)
	return err
}

const updateStationCategory = `-- name: UpdateStationCategory :exec
update station_categories
set
	name = ?
	,max = ?
where id = ?
`

type UpdateStationCategoryParams struct {
	Name string
	Max  int64
	ID   int64
}

func (q *Queries) UpdateStationCategory(ctx context.Context, arg UpdateStationCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateStationCategory, arg.Name, arg.Max, arg.ID)
	return err
}

const updateStationHost = `-- name: UpdateStationHost :exec

update stations
set
	updated_at = ?
	,updated_by = ?
	,name = ?
	,size = ?
	,category_id = ?
	,description = ?
	,requirements = ?
	,vegan = ?
	,tribe_id = ?
	,position_id = ?
where
	id = ?
`

type UpdateStationHostParams struct {
	UpdatedAt    int64
	UpdatedBy    sql.NullInt64
	Name         string
	Size         int64
	CategoryID   sql.NullInt64
	Description  sql.NullString
	Requirements sql.NullString
	Vegan        int64
	TribeID      int64
	PositionID   sql.NullInt64
	ID           int64
}

// -- name: Debug :one
// select
//
//	*
//
// from images
// where
//
//	(filepath = @path OR false = cast(@filter_by_path as bool) ) OR
//	(station_id = @station OR @station IS NULL);
func (q *Queries) UpdateStationHost(ctx context.Context, arg UpdateStationHostParams) error {
	_, err := q.db.ExecContext(ctx, updateStationHost,
		arg.UpdatedAt,
		arg.UpdatedBy,
		arg.Name,
		arg.Size,
		arg.CategoryID,
		arg.Description,
		arg.Requirements,
		arg.Vegan,
		arg.TribeID,
		arg.PositionID,
		arg.ID,
	)
	return err
}

const updateStationRole = `-- name: UpdateStationRole :exec
update station_roles
set
	station_role = ?
	,updated_by = ?
	,updated_at = ?
where id = ?
`

type UpdateStationRoleParams struct {
	StationRole acl.ACL
	UpdatedBy   sql.NullInt64
	UpdatedAt   int64
	ID          int64
}

func (q *Queries) UpdateStationRole(ctx context.Context, arg UpdateStationRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateStationRole,
		arg.StationRole,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateTribeIcon = `-- name: UpdateTribeIcon :exec
update tribe_icons
set
	created_at = unixepoch()
	,created_by = ?
	,image = ?
where id = ?
`

type UpdateTribeIconParams struct {
	CreatedBy sql.NullInt64
	Image     []byte
	ID        int64
}

func (q *Queries) UpdateTribeIcon(ctx context.Context, arg UpdateTribeIconParams) error {
	_, err := q.db.ExecContext(ctx, updateTribeIcon, arg.CreatedBy, arg.Image, arg.ID)
	return err
}

const updateTribeRole = `-- name: UpdateTribeRole :exec
update tribe_roles
set
	tribe_role = ?
	,accepted_at = ?
	,updated_by = ?
	,updated_at = ?
where id = ?
`

type UpdateTribeRoleParams struct {
	TribeRole  acl.ACL
	AcceptedAt sql.NullInt64
	UpdatedBy  sql.NullInt64
	UpdatedAt  int64
	ID         int64
}

func (q *Queries) UpdateTribeRole(ctx context.Context, arg UpdateTribeRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateTribeRole,
		arg.TribeRole,
		arg.AcceptedAt,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
update users
set
	last_login = ?
	,username = ?
	,firstname = ?
	,lastname = ?
	,email = ?
where id = ?
`

type UpdateUserParams struct {
	LastLogin int64
	Username  string
	Firstname string
	Lastname  string
	Email     string
	ID        int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.LastLogin,
		arg.Username,
		arg.Firstname,
		arg.Lastname,
		arg.Email,
		arg.ID,
	)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
update users
set role = ?
where id = ?
`

type UpdateUserRoleParams struct {
	Role acl.ACL
	ID   int64
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRole, arg.Role, arg.ID)
	return err
}

const upsertPointToGroup = `-- name: UpsertPointToGroup :exec
insert into points_to_groups (created_by, updated_by, station_id, group_id, points)
values (?,?,?,?,?)
on conflict do update set
	points = excluded.points
	,updated_by = excluded.updated_by
`

type UpsertPointToGroupParams struct {
	CreatedBy sql.NullInt64
	UpdatedBy sql.NullInt64
	StationID int64
	GroupID   int64
	Points    int64
}

func (q *Queries) UpsertPointToGroup(ctx context.Context, arg UpsertPointToGroupParams) error {
	_, err := q.db.ExecContext(ctx, upsertPointToGroup,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.StationID,
		arg.GroupID,
		arg.Points,
	)
	return err
}

const upsertPointToStation = `-- name: UpsertPointToStation :exec
insert into points_to_stations (created_by, updated_by, group_id, station_id, points)
values (?,?,?,?,?)
on conflict do update set
	points = excluded.points
	,updated_by = excluded.updated_by
`

type UpsertPointToStationParams struct {
	CreatedBy sql.NullInt64
	UpdatedBy sql.NullInt64
	GroupID   int64
	StationID int64
	Points    int64
}

func (q *Queries) UpsertPointToStation(ctx context.Context, arg UpsertPointToStationParams) error {
	_, err := q.db.ExecContext(ctx, upsertPointToStation,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.GroupID,
		arg.StationID,
		arg.Points,
	)
	return err
}
